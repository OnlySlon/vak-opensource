Кросс-система программирования для процессора PIC 17c4X
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Состав системы:
1) CC17 - компилятор языка Си
2) AS17 - ассемблер
3) DIS17 - дизассемблер
4) SIM17 - симулятор процессора
5) LIB17 - слубная библиотека

Симулятор SIM17
~~~~~~~~~~~~~~~
Вызов:
	sim17 [-d] file.hex

Флаг "-d" включает отладочную печать.  Многократное
повторение флага увеличивает подробность диагностической
печати.

Симулятор имитирует работу реального процессора PIC 17c4X,
упрощая отладку программного обеспечения.
Особенности:
- Биты статуса DC и OV отсутствуют.
- Нет sleep и watchdog таймеров.
- Моделируется работа таймера 0.
- Моделируется работа асинхронного порта.

В файле hello.s находится пример тестовой программы для
проверки симулятора.  Для запуска необходимо оттранслировать
файл командой "as17 hello.s" и запустить симулятор командой
"sim17 hello.hex".


Дизассемблер DIS17
~~~~~~~~~~~~~~~~~~
Вызов:
	dis17 file.hex

Дизассемблер печатает содержимое бинарного файла
в виде команд ассемблера.  Формат выдачи:

    <адрес>: <байт1> <байт2> <команда> <аргументы>


Ассемблер AS17
~~~~~~~~~~~~~~
Вызов:
	as17 [-O] [-o outfile.hex] [-l libdir] infile.s ...

Ассемблер транслирует набор входных файлов
в выходной бинарный файл.

Флаг -O включает оптимизацию: устранение недостижимых команд
и избыточных пересылок аккумулятора.

Флаг -l подключает каталог с библиотечными функциями.
По умолчанию подключен каталог /usr/local/lib/pic17.

Числа бывают: десятичные, восьмеричные, шестнадцатеричные,
двоичные и символьные константы. Шестнадцатеричные числа начинаются
с префикса "0x" или "0X" и могут содержать цифры или буквы "abcdefABCDEF".
Двоичные числа начинаются с префикса "0b" или
"0B" и могут содержать только цифры "01".
Восьмеричные числа начинаются с цифры "0" и могут содержать только
цифры "01234567".  Десятичные числа начинаются с цифр "123456789".
Символьные константы представляют собой произвольный символ,
заключенный в одиночные кавычки, и обозначают ASCII-код соответствующего
символа.

Для обозначения кодов служебных символов применяются
специальные символьные константы:

	'\a' - символ 007
	'\b' - символ 010
	'\t' - символ 011
	'\n' - символ 012
	'\v' - символ 013
	'\f' - символ 014
	'\r' - символ 015
	'\'' - символ одиночной кавычки
	'\\' - символ бэкслэш

Идентификаторы начинаются с буквы и могут состоять из букв и цифр.

Названия команд ассемблера могут включать символы "+-*=.?<>!&|^".

Комментарии начинаются с символов ";" или "#" и продолжаются
до конца строки.

Директива .EQU
--------------
Формат:
	имя     .equ    значение

Значение должно быть целым числом или выражением.

Директива .DATA
---------------
Формат:
	имя     .data   длина

В области данных (0x20-0xff) отводится массив указанной длины
(в байтах).  Имя обозначает адрес начала массива.

Директива .CONST
----------------
Формат:
	имя     .const  значение,значение...

Указанный массив значений размещается в конце памяти команд.
Имя обозначает адрес начала массива.  Значения считаются
байтовыми константами.

Директива .ORG
----------------
Формат:
	.org    адрес

Размещение последующих команд происходит, начиная
с указанного адреса.

Директива .CONFIG
-----------------
Формат:
	.config параметр,параметр...

Установка конфигурации процессора:

    microprocessor - конфигурация с внешней памятью
    extended       - расширенная конфигурация
    protected      - защищенная конфигурация
    watchdog       - сторожевой таймер 1:1
    watchdog64     - сторожевой таймер 1:64
    watchdog256    - сторожевой таймер 1:256
    nowatchdog     - без сторожевого таймера
    rc             - RC-генератор
    extclock       - внешний генератор
    crystal        - внешний кварц
    lowcrystal     - низкочастотный кварц

По умолчанию установлен режим микроконтроллера,
с внешним генератором, без сторожевого таймера.

Команды ассемблера имеют формат:

	метка:  мнемоника
или
	метка:  мнемоника  операнд
или
	метка:  мнемоника  операнд, регистр
или
	метка:  мнемоника  регистр, операнд
или
	метка:  мнемоника  операнд, бит

Метка может отсутствовать (вместе с двоеточием).

Команды могут иметь ни одного, один или два аргумента.

Команды без аргумента
---------------------
    nop     0000 - пустая команда
    sleep   0003 - вход в спящий режим
    awake   0004 - сброс сторожевого таймера
    ret     0002 - возврат из процедуры
    reti    0005 - возврат и разрешение прерываний
    az      290a - обнуление сумматора
    as      2b0a - установка сумматора в 0xff
    ac      130a - побитовое инвертирование сумматора
    aw      1d0a - обмен местами старших и младший 4-х битов сумматора
    a?      330a - выполнение следущей команды при ненулевом сумматоре
    z?      9a04 - выполнение следущей команды при условии нуля
    nz?     9204 - выполнение следущей команды при условии не-нуля
    c?      9804 - выполнение следущей команды при условии переноса
    nb?     9804 - выполнение следущей команды при условии не-заема (переноса)
    b?      9004 - выполнение следущей команды при условии не-переноса (заема)
    nc?     9004 - выполнение следущей команды при условии не-переноса
    a++?    1f0a - инкремент сумматора и условное выполнение
		   следущей команды при ненулевом результате
    a++z?   250a - инкремент сумматора и условное выполнение
		   следущей команды при нулевом результате
    a--?    170a - декремент сумматора и условное выполнение
		   следущей команды при ненулевом результате
    a--z?   270a - декремент сумматора и условное выполнение
		   следущей команды при нулевом результате

Команды с одним аргументом
--------------------------
    atx     01.. - запись сумматора по адресу
    a-bx    02.. - вычитание сумматора и бита заема из аргумента на сумматор
    x-ba    03.. - вычитание сумматора и бита заема из аргумента
    a-x     04.. - вычитание сумматора из аргумента на сумматор
    x-a     05.. - вычитание сумматора из аргумента
    x--a    06.. - вычитание единицы из аргумента на сумматор
    x--     07.. - декремент содержимого по адресу
    a|x     08.. - побитовое "или" аргумента к сумматору
    x|a     09.. - побитовое "или" сумматора к аргументу
    a&x     0a.. - побитовое "и" аргумента к сумматору
    x&a     0b.. - побитовое "и" сумматора к аргументу
    a^x     0c.. - побитовое "исключающее или" аргумента к сумматору
    x^a     0d.. - побитовое "исключающее или" сумматора к аргументу
    a+x     0e.. - сложение аргумента к сумматору
    x+a     0f.. - сложение сумматора к аргументу
    a+cx    10.. - сложение аргумента и бита переноса к сумматору
    x+ca    11.. - сложение сумматора и бита переноса к аргументу
    xca     12.. - побитовое инвертирование аргумента на сумматор
    xc      13.. - побитовое инвертирование аргумента
    x++a    14.. - прибавление единицы к аргументу на сумматор
    x++     15.. - прибавление единицы к аргументу
    x--a?   16.. - вычитание единицы из аргумента на сумматор и условное выполнение
		   следущей команды при ненулевом результате
    x--?    17.. - декремент содержимого по адресу и условное выполнение
		   следущей команды при ненулевом результате
    xc>>a   18.. - сдвиг бита переноса и аргумента вправо на сумматор
    xc>>x   19.. - сдвиг бита переноса и аргумента вправо
    xc<<a   1a.. - сдвиг бита переноса и аргумента влево на сумматор
    xc<<x   1b.. - сдвиг бита переноса и аргумента влево
    xwa     1c.. - обмен местами половин аргумента на сумматор
    xw      1d.. - обмен местами половин аргумента
    x++a?   1e.. - прибавление единицы к аргументу на сумматор и условное выполнение
		   следущей команды при ненулевом результате
    x++?    1f.. - инкремент содержимого по адресу и условное выполнение
		   следущей команды при ненулевом результате
    x>>a    20.. - сдвиг аргумента вправо на сумматор
    x>>x    21.. - сдвиг аргумента вправо
    x<<a    22.. - сдвиг аргумента влево на сумматор
    x<<x    23.. - сдвиг аргумента влево
    x++az?  24.. - прибавление единицы к аргументу на сумматор и условное выполнение
		   следущей команды при нулевом результате
    x++z?   25.. - инкремент содержимого по адресу и условное выполнение
		   следущей команды при нулевом результате
    x--az?  26.. - вычитание единицы из аргумента на сумматор и условное выполнение
		   следущей команды при нулевом результате
    x--z?   27.. - декремент содержимого по адресу и условное выполнение
		   следущей команды при нулевом результате
    xza     28.. - обнуление аргумента и сумматора
    xz      29.. - обнуление аргумента
    xsa     2a.. - установка аргумента и сумматора в 0xff
    xs      2b.. - установка аргумента в 0xff
    anax    2c.. - арифметическое изменение знака сумматора и запись аргумента
    anx     2d.. - арифметическое изменение знака сумматора в аргумент
    adax    2e.. - десятичная коррекция сумматора и запись аргумента
    adx     2f.. - десятичная коррекция сумматора в аргумент
    x<=a?   30.. - условное выполнение следущей команды,
		   если аргумент меньше или равен сумматору
    x!=a?   31.. - условное выполнение следущей команды,
		   если сумматор не равен аргументу
    x>=a?   32.. - условное выполнение следущей команды,
		   если аргумент больше или равен сумматору
    x?      33.. - условное выполнение следущей команды,
		   если аргумент не равен нулю
    a*x     34.. - умножение сумматора и аргумента в регистр prod
    xta     6a.. - пересылка аргумента на сумматор
    llx     a0.. - пересылка младшего байта защелки в аргумент
    lhx     a2.. - пересылка старшего байта защелки в аргумент
    xll     a4.. - пересылка аргумента в младший байт защелки
    xhl     a6.. - пересылка аргумента в старший байт защелки
    plx     a8.. - пересылка младшего байта защелки в аргумент,
		   считывание памяти команд по указателю в защелку
    pl++x   a9.. - пересылка младшего байта защелки в аргумент,
		   инкрементное считывание памяти команд по указателю в защелку
    phx     aa.. - пересылка старшего байта защелки в аргумент,
		   считывание памяти команд по указателю в защелку
    ph++x   ab.. - пересылка старшего байта защелки в аргумент,
		   инкрементное считывание памяти команд по указателю в защелку
    xhp     ae.. - пересылка аргумента в старший байт защелки,
		   запись защелки в память команд по указателю
    xhp++   af.. - пересылка аргумента в старший байт защелки,
		   инкрементная запись защелки в память команд по указателю,
    cta     b0.. - пересылка константы на сумматор
    a+c     b1.. - прибавление константы к сумматору
    c-a     b2.. - вычитание сумматора из константы
    a|c     b3.. - побитовое "или" константы к сумматору
    a^c     b4.. - побитовое "исключающее или" константы к сумматору
    a&c     b5.. - побитовое "и" константы к сумматору
    retc    b6.. - пересылка константы на сумматор и возврат из процедуры
    lcall   b7.. - вызов далекой процедуры
    reg     b8.. - установка сегмента регистров
    dat     ba.. - установка сегмента данных
    a*c     bc.. - умножение сумматора на константу в регистр prod
    goto    c... - переход по адресу (длинный аргумент)
    call    e... - вызов процедуры (длинный аргумент)

Команды с двумя аргументами
---------------------------
    rtx r,x 4... - пересылка регистра в аргумент
    xtr x,r 6... - пересылка аргумента в регистр
    bz x,b  88.. - обнуление бита
    bs x,b  80.. - установка бита
    bt x,b  38.. - инвертирование бита
    bz? x,b 90.. - условное выполнение следущей команды,
		   если бит равен нулю
    bs? x,b 98.. - условное выполнение следущей команды,
		   если бит не равен нулю

Выражения
~~~~~~~~~
Операнды команд и директив ".equ", ".data", ".org", ".const"
могут быть произвольными выражениями,
состоящими из чисел, имен, и следующих операций:

    +   сложение
    -   вычитание
    *   умножение
    /   деление
    %   остаток от деления
    &   побитовое "и"
    |   побитовое "или"
    ^   побитовое "исключающее или"
    ~   инвертированное "исключающее или"
    <<  сдвиг влево
    >>  сдвиг вправо

Все операции имеют одинаковый приоритет и выполняются слева направо.
Для изменения порядка выполнения операций применяются скобки "()".
Все операции бинарные (имеют два аргумента).
Левый аргумент может быть опущен, при этом он считается равным нулю
(это имеет смысл только для операций "+" и "~").

В выражениях может применяться специальное имя ".",
обозначающее текущий адрес команды.

Для вычисления старшего байта адреса команды применяется
специальная унарная операция "@".  Например, для вызова
далекой процедуры служит следующая последовательность команд:

	cta     @proc
	atx     PCLATH
	lcall   proc

Компилятор CC17
~~~~~~~~~~~~~~~
Вызов:
	cc17 file.c

После компиляции образуется файл "file.s" на языке ассемблера.
Особенности компилятора описаны в файле cc/NOTES.

______________________________________________
Copyright (C) 1997-1998 Cronyx Engineering Ltd.
Author Serge Vakulenko, <vak@cronyx.ru>
