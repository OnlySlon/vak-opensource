#include <stdio.h>
#include <math.h>
#include <float.h>

#define EYLER 0.577215664901532860606512

/*
 * Интегральные синус и косинус.
 *
 * Входные параметры:
 *     X   -   аргумент функции
 *
 * Выходные параметры:
 *     Si  -   интегральный синус Si(X)
 *     Ci  -   вещественная часть интегрального косинуса Ci(X).
 *             При X>0 мнимая часть равна 0, при X<0 равна -i*pi.
 *
 * Допустимые значения:
 *     X<>0    определены обе функции
 *     X=0     интегральный косинус не определен.
 *
 * Погрешность (при |X|<1 - абсолютная, при |X|>1 - относительная):
 *
 * ФУНКЦИЯ     ОБЛАСТЬ     #ТЕСТОВ         МАКС.      СРЕДН.
 * Si         [-50,50]       30000       4.4e-16     7.3e-17
 * Ci         [-50,50]       30000       6.9e-16     5.1e-17
 *
 * Cephes Math Library Release 2.1: January, 1989
 * Copyright 1984, 1987, 1989 by Stephen L. Moshier
 */
void sine_cosine_integrals (double x, double *si, double *ci)
{
	double z;
	double c;
	double s;
	double f;
	double g;
	int sg;
	double sn;
	double sd;
	double cn;
	double cd;
	double fn;
	double fd;
	double gn;
	double gd;

	if (x < 0) {
		sg = -1;
		x = -x;
	} else {
		sg = 0;
	}

	if (x == 0) {
		*si = 0;
		*ci = - DBL_MAX;
		return;
	}

	if (x > 1.0E9) {
		*si = 1.570796326794896619 - cos (x) / x;
		*ci = sin (x) / x;
		return;
	}

	if (x <= 4) {
		z = x * x;
		sn = -8.39167827910303881427E-11;
		sn = sn * z + 4.62591714427012837309E-8;
		sn = sn * z - 9.75759303843632795789E-6;
		sn = sn * z + 9.76945438170435310816E-4;
		sn = sn * z - 4.13470316229406538752E-2;
		sn = sn * z + 1.00000000000000000302E0;
		sd = 2.03269266195951942049E-12;
		sd = sd * z + 1.27997891179943299903E-9;
		sd = sd * z + 4.41827842801218905784E-7;
		sd = sd * z + 9.96412122043875552487E-5;
		sd = sd * z + 1.42085239326149893930E-2;
		sd = sd * z + 9.99999999999999996984E-1;
		s = x * sn / sd;
		cn = 2.02524002389102268789E-11;
		cn = cn * z - 1.35249504915790756375E-8;
		cn = cn * z + 3.59325051419993077021E-6;
		cn = cn * z - 4.74007206873407909465E-4;
		cn = cn * z + 2.89159652607555242092E-2;
		cn = cn * z - 1.00000000000000000080E0;
		cd = 4.07746040061880559506E-12;
		cd = cd * z + 3.06780997581887812692E-9;
		cd = cd * z + 1.23210355685883423679E-6;
		cd = cd * z + 3.17442024775032769882E-4;
		cd = cd * z + 5.10028056236446052392E-2;
		cd = cd * z + 4.00000000000000000080E0;
		c = z * cn / cd;
		if (sg != 0) {
			s = -s;
		}
		*si = s;
		*ci = 0.57721566490153286061 + log (x) + c;
		return;
	}

	s = sin (x);
	c = cos (x);
	z = 1.0 / (x * x);
	if (x < 8) {
		fn = 4.23612862892216586994E0;
		fn = fn * z + 5.45937717161812843388E0;
		fn = fn * z + 1.62083287701538329132E0;
		fn = fn * z + 1.67006611831323023771E-1;
		fn = fn * z + 6.81020132472518137426E-3;
		fn = fn * z + 1.08936580650328664411E-4;
		fn = fn * z + 5.48900223421373614008E-7;
		fd = 1.00000000000000000000E0;
		fd = fd * z + 8.16496634205391016773E0;
		fd = fd * z + 7.30828822505564552187E0;
		fd = fd * z + 1.86792257950184183883E0;
		fd = fd * z + 1.78792052963149907262E-1;
		fd = fd * z + 7.01710668322789753610E-3;
		fd = fd * z + 1.10034357153915731354E-4;
		fd = fd * z + 5.48900252756255700982E-7;
		f = fn / (x * fd);
		gn = 8.71001698973114191777E-2;
		gn = gn * z + 6.11379109952219284151E-1;
		gn = gn * z + 3.97180296392337498885E-1;
		gn = gn * z + 7.48527737628469092119E-2;
		gn = gn * z + 5.38868681462177273157E-3;
		gn = gn * z + 1.61999794598934024525E-4;
		gn = gn * z + 1.97963874140963632189E-6;
		gn = gn * z + 7.82579040744090311069E-9;
		gd = 1.00000000000000000000E0;
		gd = gd * z + 1.64402202413355338886E0;
		gd = gd * z + 6.66296701268987968381E-1;
		gd = gd * z + 9.88771761277688796203E-2;
		gd = gd * z + 6.22396345441768420760E-3;
		gd = gd * z + 1.73221081474177119497E-4;
		gd = gd * z + 2.02659182086343991969E-6;
		gd = gd * z + 7.82579218933534490868E-9;
		g = z * gn / gd;
	} else {
		fn = 4.55880873470465315206E-1;
		fn = fn * z + 7.13715274100146711374E-1;
		fn = fn * z + 1.60300158222319456320E-1;
		fn = fn * z + 1.16064229408124407915E-2;
		fn = fn * z + 3.49556442447859055605E-4;
		fn = fn * z + 4.86215430826454749482E-6;
		fn = fn * z + 3.20092790091004902806E-8;
		fn = fn * z + 9.41779576128512936592E-11;
		fn = fn * z + 9.70507110881952024631E-14;
		fd = 1.00000000000000000000E0;
		fd = fd * z + 9.17463611873684053703E-1;
		fd = fd * z + 1.78685545332074536321E-1;
		fd = fd * z + 1.22253594771971293032E-2;
		fd = fd * z + 3.58696481881851580297E-4;
		fd = fd * z + 4.92435064317881464393E-6;
		fd = fd * z + 3.21956939101046018377E-8;
		fd = fd * z + 9.43720590350276732376E-11;
		fd = fd * z + 9.70507110881952025725E-14;
		f = fn / (x * fd);
		gn = 6.97359953443276214934E-1;
		gn = gn * z + 3.30410979305632063225E-1;
		gn = gn * z + 3.84878767649974295920E-2;
		gn = gn * z + 1.71718239052347903558E-3;
		gn = gn * z + 3.48941165502279436777E-5;
		gn = gn * z + 3.47131167084116673800E-7;
		gn = gn * z + 1.70404452782044526189E-9;
		gn = gn * z + 3.85945925430276600453E-12;
		gn = gn * z + 3.14040098946363334640E-15;
		gd = 1.00000000000000000000E0;
		gd = gd * z + 1.68548898811011640017E0;
		gd = gd * z + 4.87852258695304967486E-1;
		gd = gd * z + 4.67913194259625806320E-2;
		gd = gd * z + 1.90284426674399523638E-3;
		gd = gd * z + 3.68475504442561108162E-5;
		gd = gd * z + 3.57043223443740838771E-7;
		gd = gd * z + 1.72693748966316146736E-9;
		gd = gd * z + 3.87830166023954706752E-12;
		gd = gd * z + 3.14040098946363335242E-15;
		g = z * gn / gd;
	}

	*si = 1.570796326794896619 - f * c - g * s;
	if (sg != 0) {
		*si = - *si;
	}
	*ci = f * s - g * c;
}

/*
 * Формулы взяты из книги "Коротковолновые антенны", Айзенберг и другие.
 * Страница 116, формула (6.49).
 * В книжке есть опечатки, правильные формулы такие:
 *
 * R11 = 30 [ 2 (E + ln 2bl - Ci 2bl) + sin 2bl (Si 4bl - 2 Si 2bl) +
 * 	+ cos 2bl (E + ln bl + Ci 4bl - 2 Ci 2bl) ]
 *
 * X11 = 30 [ 2 Si 2bl + sin 2bl ( E + ln bl + Ci 4bl - 2 Ci 2bl - 2 ln l/a) +
 * 	+ cos 2bl (- Si 4bl + 2 Si 2bl) ]
 *
 * b = 2 pi F sqrt (e mu) / c = 2 pi / lambda
 *
 * bl = 2 pi (l / lambda)
 */
void dipole_resistance (double l_lambda, double l_a, double *r11, double *x11)
{
	double bl, ln_bl, ln_2bl, sin_2bl, cos_2bl;
	double si_2bl, si_4bl, ci_2bl, ci_4bl, ln_l_a;

	bl = 2 * M_PI * l_lambda;

	ln_bl = log (bl);
	ln_2bl = log (2 * bl);

	sin_2bl = sin (2 * bl);
	cos_2bl = cos (2 * bl);

	sine_cosine_integrals (2 * bl, &si_2bl, &ci_2bl);
	sine_cosine_integrals (4 * bl, &si_4bl, &ci_4bl);

	ln_l_a = log (l_a);

	*r11 = 30 * (
		2 * (EYLER + ln_2bl - ci_2bl) +
		sin_2bl * (si_4bl - 2 * si_2bl) +
		cos_2bl * (EYLER + ln_bl + ci_4bl - 2 * ci_2bl)
	);

	*x11 = 30 * (
		2 * si_2bl +
		sin_2bl * (EYLER + ln_bl + ci_4bl - 2 * ci_2bl - 2 * ln_l_a) +
		cos_2bl * (- si_4bl + 2 * si_2bl)
	);
}

int main ()
{
	double l_lambda, l_a, r11, x11;

	l_a = 10000;
	printf ("# Dipole resistance for length/diameter = %g\n\n", l_a);

	for (l_lambda = 0.05; l_lambda <= 2; l_lambda += 0.005) {
		dipole_resistance (l_lambda, l_a, &r11, &x11);
		printf ("%-16.3f%-16.2f%.2f\n", l_lambda, r11, x11);
	}
	return 0;
}
/*
 * $Log: dipole.c,v $
 * Revision 1.1  2005-11-09 19:06:10  vak
 * Программа расчета сопротивления диполя.
 *
 */
